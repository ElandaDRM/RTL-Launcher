# IDE

如果您不知道使用什么IDE配置，可以从一下选项中挑选：

- VSCode + 插件rust-analyzer + 插件tauri + 插件vue
- RustRover + WebStorm

# 克隆仓库

我们假设您

- 熟悉命令行操作
- 已经安装且会使用git

```bash
git clone https://github.com/Minecraft-RTLauncher/RTLauncher
cd RTLauncher
```

# 安装依赖

您首先需要安装[deno](https://www.denojs.cn/)。deno是我们使用的JavaScript运行时，其拥有十分完整的生态，并且对比node有许多优势。

```bash
deno install
cd src-tauri
cargo check
```

# 启动调试用Build

```bash
deno task tauri dev
```

# 应用软件开发编码规范  

## 范围  

本编码规范应用于项目中所有的 Rust 代码。  

## 必须遵守本规范的人员  

- 后端开发人员  
- 后期对接全体开发成员  

## 开发环境规范  

### IDE/编辑器的配置要求：  

#### macOS：  
- rustover：处理rust底层
- WebKit: 用于在应用程序中渲染 Web 内容。

#### Windows：  
- 选择 VS2022 安装器中的 Visual Studio C++  
- `WebView2`：用于在应用程序中渲染 Web 内容  

#### Linux：  
- `GCC` 或 `Clang`：用于编译 Rust 代码和原生依赖  
- `WebKitGTK`：用于在应用程序中渲染 Web 内容  

### Rust 工具链的版本要求：  

下载最新版即可。  

## 命名规范  

- **模块**: `newModules` (小驼峰)  
- **函数/方法**: `newFunctions`  
- **变量**: `newVariable`  
- **常量**: `UPPER_SNAKE_CASE` (大写蛇形)  
- **类型 (结构体, 枚举, 特征)**: `new_enumerator` (小写蛇形)  
- **泛型**: 单个大写字母，例如 `T`, `U`  
- 遵循 Rust 的可变性 (`mut`) 和遮蔽 (`shadowing`) 约定。  

## 代码格式规范  

- 使用 `rustfmt` 自动格式化代码。  
- `use` 语句在组内按字母顺序排列。  

## 注释规范  

- 使用 `///` 为公共条目编写文档注释。  
- 使用 `//` 为内部注释，解释代码逻辑。如果要长篇解释，请使用：   
- /*  
-  * 多行注释  
-  * 多行注释  
-  */ 
- 为所有公共 API 编写较为清晰的解释
- 解释复杂的算法或不易理解的代码段。

## 日志规范

- 使用日志框架： env_logger
- 建立日志级别：
- **TRACE**：最详细的日志级别，用于记录程序运行的详细步骤
- **INFO**:用于记录程序运行过程中的一般信息，例如，服务启动、配置加载、重要状态更改等。
- **WARN**:用于记录可能出现的问题，但不会导致程序立即崩溃或无法正常工作。例如，无效的输入、过时的配置、非预期的响应等。
- **ERROR**：用于记录程序中发生的错误，这些错误可能会导致程序无法正常执行某些功能。
- **FATAL**：用于记录导致程序无法继续运行的严重错误。例如，内存耗尽、无法恢复的资源错误、系统崩溃等。
- 记录相关信息，用于调试和审计目的。
- 在日志消息中包含时间戳和上下文。

## 安全规范

- 遵循安全编码实践，以防止漏洞（例如，OWASP 指南）。
- 妥善处理错误，避免泄露敏感信息。
- 定期审计依赖项，以查找安全漏洞。
- 在程序封装方面下功夫，利用抽象类等提升代码重复使用率


### 代码审查

#### 审查流程

1. **变更准备**：
 - 开发者完成代码编写后，确保所有更改都已经本地测试通过，并且代码符合项目的编码规范。开发者应准备好详细的变更描述，说明更改的目的和主要内容。
2. **综合评审**：
 - 所有代码变更默认都需要经过审查。团队成员共同确定一位或多位审查者来对代码进行全面评审。
 - 这一阶段涵盖了编码规范、逻辑正确性、边界条件处理、异常情况管理等方面的检查。
 - 审查者还需确认相关开发文档是否已同步更新，与代码保持一致。
 - 如果发现任何问题或改进建议，审查者应当直接与开发者交流，以澄清问题并提供指导。沟通可以通过面对面交谈、即时消息、邮件等方式进行。
3. **反馈与修改**：
 - 审查完成后，审查者应向开发者提供详细的书面反馈，列出发现的问题及改进建议。开发者根据这些反馈进行必要的修改，并通知审查者再次审查。
 - 对于较为紧急或简单的修正，审查者可以与开发者协商，允许开发者直接做出调整，而无需重新发起全面审查。
4. **最终批准**：
 - 当所有问题都得到解决，且代码达到了预期的质量水平时，审查者给予最终批准。此时，代码变更可以被应用到项目中，进入下一个开发阶段或部署准备。
 - 在最终批准前，审查者还可以进行一次快速的最后检查，确保没有遗漏的问题。
5. **记录审查结果**：
 - 每次代码审查的结果，包括发现的问题、采取的行动以及任何重要的讨论点，都应被简要记录下来，以便未来参考和学习。

#### 规范性审查标准

1. **编码规范**
 - 变量、函数、类等命名应符合项目约定的命名规则（详见“编码规范”章节），并确保名称具有描述性和可读性。
 - 代码格式化应保持一致，建议使用自动格式化工具（详见“编码规范”章节）。
 - 关键逻辑和复杂算法应添加适当的注释，解释代码的目的和工作原理。

2. **文档同步**
 - 所有相关的开发文档应与代码变更同步更新，确保文档内容与实际代码保持一致。不合格的开发文档可能包括但不限于以下几类问题：
  1. **内容不一致**：
   - 文档内容未反映最新的代码变更。
   - 缺少关键功能或模块的说明。
   - 文档中的示例代码无法运行或与实际代码不符。
  2. **信息缺失**：
   - 缺乏对新功能或重大变更的详细说明。
   - 缺少必要的安装、配置或使用指南。
   - 没有记录重要的边界条件或异常情况处理。
  3. **格式与风格不符合规范**：
   - 文档格式不统一，影响阅读体验。
   - 使用了非标准的技术术语或缩写，导致理解困难。
   - 缺少必要的图表、架构图或流程图，难以直观理解系统结构。
  4. **版本管理不当**：
   - 文档版本号未及时更新，无法追踪最新版本。
   - 缺少历史版本记录，难以回溯变更历史。
   - 版本间的差异未清晰标注，容易引起混淆。
 - 每次变更应记录在版本历史或变更日志中，说明更改的原因、内容及其影响范围。

#### 正确性审查标准

1. **逻辑正确性**
 - 代码应实现预期的功能，并通过本地测试验证其正确性。
 - 边界条件处理：代码应正确处理各种边界条件和异常情况，确保系统在极端情况下也能稳定运行。
 - 性能优化：代码应尽量优化性能，避免不必要的资源消耗。对于可能影响性能的关键部分，应考虑进行性能测试和分析。

2. **安全性**
 - 输入验证：所有外部输入都应经过严格的验证和清理，防止SQL注入、跨站脚本攻击（XSS）等常见安全漏洞。
 - 敏感信息保护：确保代码中不包含硬编码的密码或其他敏感信息，并采取适当措施保护用户数据的安全。

#### 修正性审查标准

1. **技术指导与交流**
 - 对于低技术成员提交的代码，高技术成员应给出详细的修改意见和技术指导，帮助其改进代码质量。
 - 审查者应提供明确的理由，指出具体问题所在，并提出具体的改进建议，以促进团队整体的技术提升。

### 审查结果及其处理

#### 总则

审查结果不仅仅是简单的通过或不通过两种状态。为了更好地管理代码变更并确保项目的灵活性和质量，RTL项目定义了以下几种审查结果状态：

1. **通过**
2. **不通过**
3. **Workaround标记**
4. **通过但待优化**

每种状态对应不同的处理方式，具体如下：

#### 处理原则

1. **透明度**：每次审查结果都应详细记录，确保团队成员了解每个变更的状态和原因。
2. **及时性**：对于标记为Workaround的变更，应及时安排修复计划，避免长期遗留问题。
3. **持续改进**：通过但待优化的状态应鼓励开发者在未来版本中不断改进代码质量。

#### 审查结果状态及处理方式

1. **通过**
 - **定义**：代码和文档完全符合所有审查标准，无任何问题。
 - **处理方式**：
  - 变更可以直接合并到主分支或其他目标分支。
  - 记录审查结果（详见“代码审查”章节）。
2. **不通过**
 - **定义**：代码或文档存在严重问题，未能满足审查标准。
 - **处理方式**：
  - 审查者应提供明确的理由和具体的改进建议。
  - 开发者根据反馈进行必要的修改，并重新提交变更供再次审查。
  - 修改后的变更需经过完整的审查流程。
3. **Workaround标记**
 - **定义**：在紧急情况下，代码或文档虽然存在问题，但可以通过临时解决方案（Workaround）暂时解决问题，以满足当前需求。
 - **处理方式**：
  - 审查者应在审查记录中详细说明问题所在及临时解决方案的具体内容。
  - 标记为Workaround的状态应尽快安排后续修复计划，避免长期遗留问题。
  - 对Workaround标记的具体处理将在后续章节“工作标签”中的“Workaround”篇章详细叙述。
4. **通过但待优化**
 - **定义**：代码和文档基本符合审查标准，但在某些方面仍有改进空间，建议进一步优化。
 - **处理方式**：
  - 变更可以合并到主分支或其他目标分支，但应记录需要优化的地方。
  - 审查者应提供具体的优化建议，供开发者在未来版本中参考和改进。
  - 优化工作可以根据优先级安排在未来的开发周期中。

### 程序测试

#### 单元测试

##### 测试目标

1. **功能验证**：确保每个函数或类在各种输入条件下都能正确执行。
2. **边界条件处理**：验证代码能否正确处理边界条件和异常情况。
3. **代码覆盖率**：尽量提高单元测试的覆盖率，特别是关键业务逻辑。

##### 实施方法与建议

1. **编写测试用例**
 - 每个函数或类应至少有一个对应的测试用例，覆盖主要功能。
 - 包括正向测试（正常输入）和负向测试（异常输入），确保所有边界条件都得到充分验证。
2. **隔离外部依赖**
 - 使用适当的手段隔离外部依赖，如数据库连接、网络请求等，专注于测试核心逻辑。
3. **保持测试独立性**
 - 每个测试用例应独立运行，避免依赖其他测试用例的状态或结果，确保测试结果的可重复性和稳定性。
4. **快速反馈**
 - 优化测试用例，确保单元测试能在几秒钟内完成，以便开发者能够快速获得反馈并进行调整。
5. **定期审查测试用例**
 - 定期审查和更新测试用例，确保其与最新的代码变更保持一致。
 - 删除不再适用的测试用例，避免浪费时间和资源。
6. **文档化测试策略**
 - 记录单元测试的目标、范围和实现方法，帮助团队成员了解测试策略，并提供详细的注释和说明。

#### 集成测试

##### 测试目标

1. **模块间协作**：验证不同模块之间能否正确传递数据和调用接口。
2. **系统完整性**：确保各个模块组合在一起后能按预期运行。

##### 实施方法与建议

1. **定义测试范围**
 - 确定需要进行集成测试的关键功能模块和接口，明确测试的重点。
2. **准备测试环境**
 - 准备接近生产环境的测试环境，包括必要的配置和依赖。
3. **编写测试用例**
 - 编写覆盖模块间接口调用和数据传递的测试用例，确保关键路径被充分验证。
 - 包括正向测试（正常输入）和负向测试（异常输入），确保边界条件得到验证。
4. **逐步集成**
 - 采用逐步集成的方式，先测试较小的模块组合，再扩展到更大的部分，以便更容易定位和解决问题。
5. **保持测试独立性**
 - 每个测试用例应独立运行，避免全局状态或共享资源，确保测试结果的可重复性和稳定性。
6. **文档化测试策略**
 - 记录集成测试的目标、范围和实现方法，提供详细的注释和说明。

### 内部测试

##### 测试活动与建议

1. **功能测试**
 - 验证启动器的所有功能是否按预期工作，包括用户界面交互、配置文件处理、游戏版本管理等关键功能。
2. **性能测试**
 - 评估启动器在各种条件下的响应时间和资源消耗，确保在高负载或复杂环境下仍能稳定运行。
3. **安全测试**
 - 检查启动器是否存在安全漏洞，如输入验证不足、敏感信息泄露等，确保符合相关的安全标准和最佳实践。
4. **回归测试**
 - 在每次修复缺陷或添加新功能后，进行回归测试以确保未引入新的问题，重点测试受影响的功能模块及相关联的部分。
5. **记录详细日志**
 - 记录详细的测试日志，包括测试步骤、输入数据、预期结果和实际结果，便于问题排查。
6. **邀请内部用户参与**
 - 邀请团队成员或信任的用户参与内部测试，收集他们的反馈和意见，帮助发现更多潜在问题。

### 公开测试

##### 测试活动与建议
1. **发布测试版本**
 - 向公众发布一个稳定的测试版本（Beta版），提供详细的安装指南和已知问题列表，帮助用户顺利参与测试。
2. **收集用户反馈**
 - 通过论坛、社交媒体、邮件等渠道收集用户的反馈和意见，设立专门的反馈收集机制，如在线表单或专用邮箱。
3. **监控运行日志**
 - 使用远程日志收集工具捕获启动器的运行日志，分析用户遇到的问题，监控启动器的性能指标，识别潜在的性能瓶颈。
4. **社区互动**
 - 积极参与社区讨论，及时回应用户的疑问和建议，定期发布测试进展更新，保持与测试用户的沟通透明度。
5. **问题跟踪与修复**
 - 将用户报告的问题记录在缺陷跟踪系统中，详细描述问题现象、重现步骤和预期结果，优先处理关键问题，并定期发布修复补丁。
6. **保护用户隐私**
 - 确保在收集用户数据时遵守相关法律法规，保护用户的隐私和个人信息，明确告知用户数据的用途和存储方式，获得用户的同意。

### 测试结果及其处理

#### 处理流程

1. **问题分类**
 - 根据问题的性质和严重程度进行分类，如功能缺陷、性能问题、安全漏洞等。
2. **优先级划分**
 - 根据问题的影响范围和紧急程度，确定修复的优先级。
3. **分配责任人**
 - 为每个问题分配具体的开发人员或团队，确保问题得到及时处理。
4. **问题跟踪**
 - 使用缺陷跟踪系统（如Jira、Trello）记录和跟踪每个问题的状态，从报告、确认、修复到验证的整个过程。
5. **修复验证**
 - 修复完成后，由测试人员进行验证，确保问题已被彻底解决，并且没有引入新的问题。
6. **更新文档**
 - 根据修复内容更新相关文档，确保文档与代码保持一致，帮助团队成员和未来维护者理解更改。

#### 沟通与反馈

1. **内部沟通**
 - 定期召开会议，讨论测试结果和问题处理进度，确保团队成员之间的信息同步。
2. **外部反馈**
 - 对于公开测试中的用户反馈，及时回复并更新用户关于问题处理的进展，保持良好的沟通和透明度。

#### 总结与改进

1. **总结经验**
 - 每次测试结束后，总结测试过程中遇到的问题和解决方案，积累经验和教训。
2. **持续改进**
 - 根据测试结果和反馈，不断优化测试流程和方法，提升测试效率和质量。

### 工作标签

#### 标签类型与定义

- **TODO**
  - 标记需要完成的任务或待办事项。
- **Workaround**
  - 标记临时解决方案或变通方法。
- **Bug**
  - 标记发现的缺陷或错误。
- **Feature**
  - 标记新功能的需求或开发任务。
- **Enhancement**
  - 标记对现有功能的改进或优化任务。
- **Question**
  - 标记需要澄清或讨论的问题。
- **Blocked**
  - 标记因外部依赖或其他原因而无法继续的任务。
- **OnGoing**
  - 标记正在进行中的任务。
- **Review**
  - 标记需要审核的任务或代码。
- **Performance**
  - 标记与系统性能相关的问题或优化任务。
- **Security**
  - 标记与安全相关的问题或任务。
- **UserFeedback**
  - 标记来自用户的反馈或建议。
- **Duplicate**
  - 标记重复的任务或问题。
- **NOTFIX**
  - 标记不会被修复的问题，通常是因为影响较小或成本过高。

## 其他规范

#### 版本号构成

版本号采用扩展的语义化版本控制标准，格式为 `ProjectName Prefix Major.Minor.Identifier.Incremental`，各部分含义如下：

- **ProjectName**：项目的名称，如 "RTL"。
- **Prefix**：版本前缀，用于区分不同发行版或测试阶段，如 "alpha", "beta", "rc"（Release Candidate）或正式版 "release"。
- **Major**：主版本号。当引入不兼容的API更改时增加。
- **Minor**：次版本号。当添加向后兼容的功能时增加。
- **Identifier**：标识符版本号。表示开发进度或特定版本特征。
- **Incremental**：增量版本号。表示具体的构建次数或尝试次数。

例如：
- `RTL alpha 0.0.0.10` 表示 RTL 项目的第10次 alpha 测试版本。
- `RTL beta 1.0.0.5` 表示 RTL 项目的第5次 beta 测试版本，基于主版本1.0.0。
- `RTL rc 1.0.0.1` 表示 RTL 项目的第一个发布候选版本，基于主版本1.0.0。
- `RTL release 1.0.0.0` 表示 RTL 项目的正式发布版本1.0.0。

#### 使用方法与建议

1. **明确版本变更**
 - 每次发布新版本时，详细记录变更内容，包括新增功能、修复的问题和其他重要信息。
2. **保持一致**
 - 确保团队成员对版本号规则有一致的理解，避免混淆和误解。
3. **定期发布**
 - 定期发布新版本，确保用户能够及时获得最新的功能和修复。
4. **沟通与透明度**
 - 及时向用户和利益相关者传达版本更新的信息，保持沟通透明度。
5. **数据结构**
 - 确保版本号中的数字部分在 `0` 到 `2^31-1` 范围内，选择合适的数据结构存储这些数值。
6. **安全考虑**
 - 确保版本名和前缀的长度限制在合理范围内，防止字符串注入攻击。版本名长度应在 `3` 到 `511` 字节之间，前缀长度不应超过 `127` 字节。
